Trabajo final AD:
--La tabla obra contiene la información de las obras literarias.

CREATE TABLE obra (
id CHAR(5),
titulo VARCHAR(100),
anyo INTEGER,
CONSTRAINT PK_obra PRIMARY KEY (id),
CONSTRAINT NN_titulo CHECK (titulo IS NOT NULL)
);


--La tabla autor contiene la información de los autores de las obras.

CREATE TABLE autor (
id CHAR(4),
nombre VARCHAR(30),
apellidos VARCHAR(60),
nacimiento DATE,
CONSTRAINT PK_autor PRIMARY KEY (id),
CONSTRAINT NN_nombre CHECK (nombre IS NOT NULL),
CONSTRAINT NN_apellidos CHECK (apellidos IS NOT NULL)
);


--La tabla autor_obra contiene la relación de autores y obras.

CREATE TABLE autor_obra (
id_autor CHAR(4),
id_obra CHAR(5),
CONSTRAINT PK_autor_obra PRIMARY KEY (id_autor, id_obra),
CONSTRAINT FK_autor_obra_id_autor FOREIGN KEY (id_autor) REFERENCES
autor(id),
CONSTRAINT FK_autor_obra_id_obra FOREIGN KEY (id_obra)
REFERENCES obra(id)
);



--La tabla edicion contiene la información de las ediciones publicadas de las obras.

CREATE TABLE edicion (
id CHAR(6),
id_obra CHAR(5),
isbn VARCHAR(20),
anyo INTEGER,
CONSTRAINT PK_edicion PRIMARY KEY (id),
CONSTRAINT NN_id_obra CHECK (id_obra IS NOT NULL),
CONSTRAINT NN_isbn CHECK (isbn IS NOT NULL),
CONSTRAINT FK_edicion FOREIGN KEY (id_obra) REFERENCES
obra(id)
);




--La tabla ejemplar contiene la información de los ejemplares adquiridos por labiblioteca.

CREATE TABLE ejemplar (
id_edicion CHAR(6),
numero INTEGER,
alta DATE,
baja DATE,
CONSTRAINT PK_ejemplar PRIMARY KEY (id_edicion, numero),
CONSTRAINT FK_ejemplar FOREIGN KEY (id_edicion) REFERENCES
edicion(id),
CONSTRAINT NN_alta CHECK (alta IS NOT NULL)
);

Select * from obra;
Select * from autor;
Select * from autor_obra;
Select * from edicion;
Select * from ejemplar;
Select * from historial_obras;
///////////////////////////////////////////////////////////////////////////////////

--Tabla para guardar los borrados (se utiliza en el punto 9.1)

CREATE TABLE historial_obras (
   id CHAR(5),
   titulo VARCHAR(100),
   anyo INTEGER,
   fecha_borrado TIMESTAMP,
   CONSTRAINT PK_historial_obras PRIMARY KEY (id, fecha_borrado)
);

CREATE TABLE historial_autor (
   id CHAR(4),
   nombre VARCHAR(30),
   apellidos VARCHAR(60),
   nacimiento DATE,
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50),
   CONSTRAINT FK_historial_autor_id FOREIGN KEY (id) REFERENCES autor(id),
   CONSTRAINT PK_historial_autor PRIMARY KEY (id, fecha_cambio)
);


CREATE TABLE historial_autor_obra (
   id_autor CHAR(4),
   id_obra CHAR(5),
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50), 
   CONSTRAINT FK_historial_autor_obra_id_autor FOREIGN KEY (id_autor) REFERENCES autor(id),
   CONSTRAINT FK_historial_autor_obra_id_obra FOREIGN KEY (id_obra) REFERENCES obra(id)
);

CREATE TABLE historial_edicion (
   id CHAR(6),
   id_obra CHAR(5),
   isbn VARCHAR(20),
   anyo INTEGER,
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50),
   CONSTRAINT FK_historial_edicion_id_edicion FOREIGN KEY (id) REFERENCES edicion(id),
   CONSTRAINT FK_historial_edicion_id_obra FOREIGN KEY (id_obra) REFERENCES obra(id),
   CONSTRAINT PK_historial_edicion PRIMARY KEY (id, fecha_cambio)
);

CREATE TABLE historial_ejemplar (
   id_edicion CHAR(6),
   numero INTEGER,
   alta DATE,
   baja DATE,
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50),
   CONSTRAINT FK_historial_ejemplar_id_edicion FOREIGN KEY (id_edicion) REFERENCES edicion(id),
   CONSTRAINT PK_historial_ejemplar PRIMARY KEY (id_edicion, numero, fecha_cambio)
);

//////////////////////////////////////////////////////////////////////////////////////
06. Los identificadores serán alfanuméricos y generados de forma aleatoria. Por
supuesto habrá que tener en cuenta antes de realizar la inserción que la PK no esté
duplicada, caso de estarlo terminaremos de forma controlada el intento de inserción
monitorizando por pantalla el error.


DECLARE

   id4 CHAR(4);
   id5 CHAR(5); 
   id6 CHAR(6);

BEGIN
   -- Generar un identificador alfanumérico de 4 caracteres
   id4 := DBMS_RANDOM.STRING('X', 4);
   -- Generar un identificador alfanumérico de 5 caracteres
   id5 := DBMS_RANDOM.STRING('X', 5);
   -- Generar un identificador alfanumérico de 6 caracteres
   id6 := DBMS_RANDOM.STRING('X', 6);
   -- Intentar insertar una obra
   BEGIN
      INSERT INTO obra (id, titulo) VALUES (id5, 'Cinco semanas en globo');
      INSERT INTO autor (id, nombre, apellidos, nacimiento) VALUES (id4, 'Julio', 'Verne', TO_DATE('1828-02-08', 'YYYY-MM-DD'));
      INSERT INTO autor_obra(id_autor, id_obra) VALUES (id4,id5);
      INSERT INTO edicion(id, id_obra, isbn, anyo) VALUES (id6, id5,'1234567890',2022);
      INSERT INTO ejemplar (id_edicion, numero, alta, baja) VALUES (id6, 1, TO_DATE('2022-03-01', 'YYYY-MM-DD'), NULL);
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         -- Capturar la excepción si la clave primaria está duplicada
         DBMS_OUTPUT.PUT_LINE('Error: Clave primaria duplicada. Inserción abortada.');
   END;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////
08. El alta de obras se implementará mediante una función alta_obra.

CREATE OR REPLACE FUNCTION alta_obra(p_titulo VARCHAR, p_anyo INTEGER DEFAULT NULL)
RETURN VARCHAR IS
   -- Declaraciones
   id_obra VARCHAR(5);
BEGIN
   -- Generar un identificador alfanumérico de 5 caracteres
   id_obra := DBMS_RANDOM.STRING('X', 5);

   -- Insertar la nueva obra
   BEGIN
      INSERT INTO obra (id, titulo, anyo) VALUES (id_obra, p_titulo, p_anyo);
   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, devolver -1
         RETURN '-1';
   END;

   -- Devolver el ID asignado
   RETURN id_obra;
END;
/

DECLARE
   id_obr VARCHAR(5);
BEGIN
   -- Supongamos que se quiere insertar una obra con el título 'Cinco semanas en globo'
   id_obr := alta_obra('Cinco semanas en globo',2022);

   -- Verificar si la operación fue exitosa
   IF id_obr = '-1' THEN
      DBMS_OUTPUT.PUT_LINE('Error al insertar la obra. No se pudo asignar un ID.');
   ELSE
      DBMS_OUTPUT.PUT_LINE('ID asignado: ' || id_obr);
   END IF;
END;
/


/////////////////////////////////////////////////////////////////////////////////////////

09. El borrado de obras se implementará mediante una función borrado_obra.
CREATE OR REPLACE FUNCTION borrado_obra(p_id VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_existencia INTEGER;
BEGIN
   v_existencia := 0;
   -- Verificar si existe la obra con el id proporcionado
   SELECT COUNT(*) INTO v_existencia
   FROM obra
   WHERE id = p_id;

   -- Realizar el borrado si la obra existe
   IF v_existencia > 0 THEN
      DELETE FROM obra WHERE id = p_id;
      RETURN 1; -- Borrado efectuado
   ELSE
      RETURN 0; -- No existe el id
   END IF;
 
   EXCEPTION
	WHEN OTHERS THEN
	   RETURN -1;
END;
/

SET SERVEROUTPUT ON; -- Esto habilita la salida de DBMS_OUTPUT

DECLARE
   resultado INTEGER;
   id_obr VARCHAR(5);
BEGIN
   -- Supongamos que ya existe una obra con el ID 'ABCDE'
   id_obr := 'XNU0I';

   -- Llamada a la función borrado_obra
   resultado := borrado_obra(id_obr);

   -- Mostrar el resultado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('La obra se ha borrado exitosamente.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe una obra con el ID proporcionado.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Ha ocurrido un error durante el borrado de la obra.');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Resultado desconocido.');
   END CASE;
END;
/


//////////////////////////////////////////////////////////////////////////////////////////

09.1 Auditoría del borrado de obras: Cada vez que se ejecute el borrado de una obra y
para no perder datos, lo que querremos es que la obra borrada y todos los datos
asociados a ella queden guardados en una/s tabla/s de histórico ocultas al usuario
estándar, de modo que en cualquier momento se pueda auditar el borrado de obras
recuperando todos sus datos y la fecha/hora en que fue borrada la obra.
CREATE OR REPLACE TRIGGER auditar_borrado_obra
AFTER DELETE ON obra
FOR EACH ROW
DECLARE
   -- Declaraciones
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar los datos de la obra borrada en la tabla de historial_obras
   INSERT INTO historial_obras (id, titulo, anyo, fecha_borrado)
   VALUES (:OLD.id, :OLD.titulo, :OLD.anyo, v_fecha_hora);
   
   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de obra ID ' || :OLD.id || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/


CREATE OR REPLACE TRIGGER auditar_borrado_autor_obra
AFTER DELETE ON autor_obra
FOR EACH ROW
DECLARE
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar la relación de autor y obra borrada en la tabla de historial_autor_obra
   INSERT INTO historial_autor_obra (id_autor, id_obra, fecha_cambio, tipo_cambio)
   VALUES (:OLD.id_autor, :OLD.id_obra, v_fecha_hora, 'DELETE en autor_obra');

   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de autor_obra ID_Autor ' || :OLD.id_autor || ' ID_Obra ' || :OLD.id_obra || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/

CREATE OR REPLACE TRIGGER auditar_borrado_edicion
AFTER DELETE ON edicion
FOR EACH ROW
DECLARE
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar los datos de la edición borrada en la tabla de historial_edicion
   INSERT INTO historial_edicion (id, id_obra, isbn, anyo, fecha_cambio, tipo_cambio)
   VALUES (:OLD.id, :OLD.id_obra, :OLD.isbn, :OLD.anyo, v_fecha_hora, 'DELETE en edicion');

   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de edicion ID ' || :OLD.id || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/

CREATE OR REPLACE TRIGGER auditar_borrado_ejemplar
AFTER DELETE ON ejemplar
FOR EACH ROW
DECLARE
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar los datos del ejemplar borrado en la tabla de historial_ejemplar
   INSERT INTO historial_ejemplar (id_edicion, numero, alta, baja, fecha_cambio, tipo_cambio)
   VALUES (:OLD.id_edicion, :OLD.numero, :OLD.alta, :OLD.baja, v_fecha_hora, 'DELETE en ejemplar');

   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de ejemplar ID_Edicion ' || :OLD.id_edicion || ' Numero ' || :OLD.numero || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10. El alta de autores se implementará mediante una función alta_autor.


CREATE OR REPLACE FUNCTION alta_autor(p_nombre VARCHAR, p_apellidos VARCHAR, p_nacimiento DATE DEFAULT NULL)
RETURN VARCHAR IS
   -- Declaraciones
   id_autor CHAR(4);
BEGIN
   -- Generar un identificador alfanumérico de 4 caracteres
   id_autor := DBMS_RANDOM.STRING('X', 4);
	
   -- Insertar la nueva obra
   BEGIN
      INSERT INTO autor (id, nombre, apellidos, nacimiento) VALUES (id_autor, p_nombre, p_apellidos, p_nacimiento);
   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, devolver -1
         RETURN '-1';
   END;

   -- Devolver el ID asignado
   RETURN id_autor;
END;
/

DECLARE
   id_autor VARCHAR(4);
BEGIN
   -- Supongamos que se quiere insertar un autor con el nombre 'Julio' y apellidos 'Cesar'
   -- y se proporciona el año de nacimiento como 2022
   id_autor := alta_autor('Julio', 'Cesar', DATE '2022-01-01');

   -- Verificar si la operación fue exitosa
   IF id_autor = '-1' THEN
      DBMS_OUTPUT.PUT_LINE('Error al insertar el autor. No se pudo asignar un ID.');
   ELSE
      DBMS_OUTPUT.PUT_LINE('ID asignado: ' || id_autor);
   END IF;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

11. El borrado de autores se implementará mediante una función borrado_autor.

CREATE OR REPLACE FUNCTION borrado_autor(p_id VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_existencia INTEGER ;

BEGIN
    v_existencia := 0;
   -- Verificar si existe la autor con el id proporcionado
   SELECT COUNT(*) INTO v_existencia
   FROM autor
   WHERE id = p_id;

   -- Intentar borrar el autor
 	IF v_existencia > 0 THEN
      DELETE FROM autor WHERE id = p_id;
      RETURN 1; -- Borrado efectuado
   ELSE
      RETURN 0; -- No existe el id
   END IF;
 
   EXCEPTION
	WHEN OTHERS THEN
	   RETURN -1;
      
END;
/
DECLARE
   resultado INTEGER;
   id_autor VARCHAR(4); 

BEGIN
    id_autor := 'TY5Q';
    resultado := borrado_autor(id_autor);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Autor borrado exitosamente.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe un autor con ese ID.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Error al intentar borrar el autor.');
   END CASE;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////


12. La vinculación de un autor a una obra se implementará mediante una función
vincular.



CREATE OR REPLACE FUNCTION vincular_autor_obra(p_id_autor VARCHAR, p_id_obra VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_resultado INTEGER := 1;  -- Por defecto, asumimos que la operación se realiza sin errores.

BEGIN
   -- Intentar vincular el autor a la obra
   BEGIN
      INSERT INTO autor_obra (id_autor, id_obra) VALUES (p_id_autor, p_id_obra);
      
      COMMIT;  -- Confirmar la transacción si la inserción fue exitosa

   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, asignar -1 al resultado y realizar un rollback
         v_resultado := -1;
         ROLLBACK;
   END;

   -- Devolver el resultado
   RETURN v_resultado;
END;
/

DECLARE
   resultado INTEGER;
   id_autor CHAR(4) ; 
   id_obra CHAR(5) ;  

BEGIN
    id_autor :='EYTW';
	id_obra :='HUF6N';
   resultado := vincular_autor_obra(id_autor, id_obra);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Vinculación exitosa.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Error al intentar vincular el autor a la obra.');
   END CASE;
END;
/

//////////////////////////////////////////////////////////////////////////////////////////////////////

13. La desvinculación de un autor de una obra se implementará mediante una función
desvincular.

CREATE OR REPLACE FUNCTION desvincular_autor_obra(p_id_autor VARCHAR, p_id_obra VARCHAR)
RETURN INTEGER IS
   -- Declaraciones
   v_resultado INTEGER := 0;  -- Por defecto, asumimos que no existe el vínculo.

BEGIN
   -- Intentar desvincular el autor de la obra
   BEGIN
      DELETE FROM autor_obra
      WHERE id_autor = p_id_autor AND id_obra = p_id_obra;

      -- Verificar si se eliminó alguna fila
      IF SQL%ROWCOUNT > 0 THEN
         -- Si se eliminó al menos una fila, asignar 1 al resultado
         v_resultado := 1;
      END IF;
      
      COMMIT;  -- Confirmar la transacción

   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, asignar -1 al resultado y realizar un rollback
         v_resultado := -1;
         ROLLBACK;
   END;

   -- Devolver el resultado
   RETURN v_resultado;
END;
/


DECLARE
   resultado INTEGER;
   id_autor VARCHAR(4) := 'EYTW';  
   id_obra VARCHAR(5) := 'HUF6N';  

BEGIN
   resultado := desvincular_autor_obra(id_autor, id_obra);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Desvinculación exitosa.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe un vínculo entre el autor y la obra.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Error al intentar desvincular el autor de la obra.');
   END CASE;
END;
/


////////////////////////////////////////////////////////////////////////////////////////////

14. El alta de ediciones se implementará mediante una función alta_edicion.

CREATE OR REPLACE FUNCTION alta_edicion(p_id_obra VARCHAR, p_isbn VARCHAR, p_anyo INTEGER DEFAULT NULL)
RETURN VARCHAR IS
   -- Declaraciones
   v_id_edicion CHAR(6);
BEGIN
   -- Generar un identificador alfanumérico de 5 caracteres para la edición
   v_id_edicion := DBMS_RANDOM.STRING('X', 6);
	
   -- Insertar la nueva edición
   BEGIN
      INSERT INTO edicion (id, id_obra, isbn, anyo) VALUES (v_id_edicion, p_id_obra, p_isbn, p_anyo);
      
      COMMIT;  -- Confirmar la transacción

   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, devolver '-1'
         RETURN '-1';
   END;

   -- Devolver el ID asignado
   RETURN v_id_edicion;
END;
/

DECLARE
   id_edicion CHAR(6);
   id_obra CHAR(5) := 'HUF6N';  -- Reemplaza 'XXXX' con el ID de la obra
   isbn_edicion CHAR(20) := '1234567890123';  -- Reemplaza con un ISBN válido
   anyo_edicion INTEGER := 2022;  -- Reemplaza con el año que desees

BEGIN
   id_edicion := alta_edicion(id_obra, isbn_edicion, anyo_edicion);

   -- Verificar el resultado y mostrar un mensaje adecuado
   IF id_edicion = '-1' THEN
      DBMS_OUTPUT.PUT_LINE('Error al dar de alta la edición. No se pudo asignar un ID.');
   ELSE
      DBMS_OUTPUT.PUT_LINE('ID de la edición asignado: ' || id_edicion);
   END IF;
END;
/


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

15. El borrado de ediciones se implementará mediante una función borrado_edicion.


CREATE OR REPLACE FUNCTION borrado_edicion(p_id VARCHAR)
RETURN INTEGER IS
   -- Declaraciones
   v_resultado INTEGER := 0;  -- Por defecto, asumimos que no se encontró el ID.

BEGIN
   -- Intentar borrar la edición por su ID
   BEGIN
      DELETE FROM edicion WHERE id = p_id;

      -- Verificar si se eliminó alguna fila
      IF SQL%ROWCOUNT > 0 THEN
         -- Si se eliminó al menos una fila, asignar 1 al resultado
         v_resultado := 1;
      END IF;
      
      COMMIT;  -- Confirmar la transacción

   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, asignar 0 al resultado y realizar un rollback
         v_resultado := 0;
         ROLLBACK;
   END;

   -- Devolver el resultado
   RETURN v_resultado;
END;
/
    
DECLARE
   resultado INTEGER;
   id_edicion_a_borrar VARCHAR(6) := 'PCA538';  

BEGIN
   resultado := borrado_edicion(id_edicion_a_borrar);

   
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Borrado de edición exitoso.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe una edición con ese ID.');
   END CASE;
END;
/


///////////////////////////////////////////////////////////////////////////////////////////////////////////
17. La operación de alta de ejemplar no requiere especificar fecha de alta, porque será la
fecha del sistema.

18. La operación de alta de ejemplar no requiere especificar el número, porque se
calculará según los ejemplares de la misma edición ya existentes (si ya hay N, pues se
dará de alta como N+1).

16. El alta de ejemplares se implementará mediante una función alta_ejemplar.
CREATE SEQUENCE SEQ_EJEMPLAR
  START WITH 1
  INCREMENT BY 1
  NOCACHE
  NOCYCLE;

CREATE OR REPLACE FUNCTION alta_ejemplar(p_id_edicion VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_numero_ejemplar INTEGER;
BEGIN
   -- Verificar si la edición con el ID proporcionado existe en la tabla edicion
   SELECT COUNT(*)
   INTO v_numero_ejemplar
   FROM edicion
   WHERE id = p_id_edicion;

   -- Si no se encuentra la edición, devolver -1
   IF v_numero_ejemplar = 0 THEN
      RETURN -1;
   END IF;

   -- Generar el número de ejemplar utilizando una secuencia
   SELECT SEQ_EJEMPLAR.NEXTVAL INTO v_numero_ejemplar FROM DUAL;

   -- Insertar el nuevo ejemplar
   BEGIN
      INSERT INTO ejemplar (id_edicion, numero, alta) VALUES (p_id_edicion, v_numero_ejemplar, SYSDATE);
      
      COMMIT;  -- Confirmar la transacción

   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, devolver -1
         RETURN -1;
   END;

   -- Devolver el número de ejemplar asignado
   RETURN v_numero_ejemplar;
END;
/

DECLARE
   numero_ejemplar_asignado INTEGER;
   id_edicion_existente VARCHAR(6) := 'F4KP37';  -- Reemplaza 'XXXXXX' con un ID de edición existente

BEGIN
   -- Probar con una edición existente
   numero_ejemplar_asignado := alta_ejemplar(id_edicion_existente);

   -- Verificar el resultado y mostrar un mensaje adecuado
   IF numero_ejemplar_asignado = -1 THEN
      DBMS_OUTPUT.PUT_LINE('No existe la edición con ese ID. No se pudo dar de alta el ejemplar.');
   ELSE
      DBMS_OUTPUT.PUT_LINE('Número de ejemplar asignado: ' || numero_ejemplar_asignado);
   END IF;

END;
/


/////////////////////////////////////////////////////////////////////////////////////////////////////////////


20. El borrado de ejemplares significa suprimir la fila correspondiente, y su aplicación
habitual será revertir un alta errónea.

21. Sólo se podrá borrar un ejemplar si es el último de su serie, no tiene fecha de baja y
además no han pasado más de 30 días desde la fecha de alta.

22. El borrado de ejemplares se implementará mediante una función borrado_ejemplar.


CREATE OR REPLACE FUNCTION borrado_ejemplar(p_id_edicion VARCHAR, p_numero INTEGER) RETURN INTEGER IS
   -- Declaraciones
   v_fecha_alta DATE;
   v_fecha_baja DATE;
   v_max_numero INTEGER;
BEGIN
   -- Obtener la fecha de alta y fecha de baja del ejemplar
   SELECT alta, baja
   INTO v_fecha_alta, v_fecha_baja
   FROM ejemplar
   WHERE id_edicion = p_id_edicion AND numero = p_numero;

   -- Verificar si existe el ejemplar
   IF v_fecha_alta IS NULL THEN
      -- No existe el ejemplar
      RETURN 0;
   END IF;

   -- Obtener el número máximo de ejemplar para la edición dada
   SELECT COALESCE(MAX(numero), 0)
   INTO v_max_numero
   FROM ejemplar
   WHERE id_edicion = p_id_edicion;

   -- Verificar si el ejemplar cumple con la cláusula 21 (último ejemplar sin fecha de baja y no han pasado más de 30 días)
   IF p_numero = v_max_numero AND v_fecha_baja IS NULL AND SYSDATE - v_fecha_alta <= 30 THEN
      -- Borrar el ejemplar
      BEGIN
         DELETE FROM ejemplar
         WHERE id_edicion = p_id_edicion AND numero = p_numero;

         COMMIT;  -- Confirmar la transacción

      EXCEPTION
         WHEN OTHERS THEN
            -- Si ocurre un error, devolver -1
            RETURN -1;
      END;

      -- Devolver 1 para indicar que el borrado fue efectuado
      RETURN 1;
   ELSE
      -- El ejemplar no cumple con la cláusula 21
      RETURN -1;
   END IF;
END;
/


DECLARE
   resultado_borrado INTEGER;
   id_edicion VARCHAR(6) := 'F4KP37';  -- Reemplaza con un ID de edición existente
   numero_ejemplar INTEGER := 2;        -- Reemplaza con el número de ejemplar existente

BEGIN
   -- Probar borrado de un ejemplar existente
   resultado_borrado := borrado_ejemplar(id_edicion, numero_ejemplar);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado_borrado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Ejemplar borrado exitosamente.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe el ejemplar con ese ID y número.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('No se pudo borrar el ejemplar. Verifica si cumple que es el último de su serie, no tiene fecha de baja y
además no han pasado más de 30 días desde la fecha de alta.');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Resultado desconocido.');
   END CASE;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

24. La operación de baja no requiere especificar la fecha, porque se utilizará la del
sistema.

25. Sólo se podrá dar de baja un ejemplar si no tiene fecha de baja.

26. La baja de ejemplares se implementará mediante una función baja_ejemplar.

CREATE OR REPLACE FUNCTION baja_ejemplar(p_id_edicion VARCHAR, p_numero INTEGER) RETURN INTEGER IS
   -- Declaraciones
   v_fecha_baja DATE;
   v_fecha_alta DATE;
BEGIN
   -- Obtener la fecha de alta y fecha de baja del ejemplar
   SELECT alta, baja
   INTO v_fecha_alta, v_fecha_baja
   FROM ejemplar
   WHERE id_edicion = p_id_edicion AND numero = p_numero;

   -- Verificar si existe el ejemplar
   IF v_fecha_alta IS NULL THEN
      -- No existe el ejemplar
      RETURN 0;
   ELSE
       -- Verificar si el ejemplar cumple con la cláusula 25 (no tiene fecha de baja)
       IF v_fecha_baja IS NULL THEN
          -- Establecer la fecha de baja como la fecha del sistema
          BEGIN
             UPDATE ejemplar
             SET baja = SYSDATE
             WHERE id_edicion = p_id_edicion AND numero = p_numero;
    
             COMMIT;  -- Confirmar la transacción
    
          EXCEPTION
             WHEN OTHERS THEN
                -- Si ocurre un error, devolver -1
                RETURN -1;
          END;
    
          -- Devolver 1 para indicar que la baja fue efectuada
          RETURN 1;
       ELSE
          -- El ejemplar ya tiene fecha de baja, por lo tanto, no cumple con la cláusula 25
          RETURN -1;
       END IF;

   END IF;


END;
/
    
DECLARE
   resultado_baja INTEGER;
   id_edicion VARCHAR(6) := 'F4KP37';  -- Reemplaza con un ID de edición existente
   numero_ejemplar INTEGER := 4;        -- Reemplaza con el número de ejemplar existente

BEGIN
   -- Probar baja de un ejemplar existente
   resultado_baja := baja_ejemplar(id_edicion, numero_ejemplar);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado_baja
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Baja de ejemplar efectuada exitosamente.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe el ejemplar con ese ID y número.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('No se pudo dar de baja el ejemplar. Verifica las condiciones de baja.');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Resultado desconocido.');
   END CASE;
END;
/


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

27. Definir una tabla con la información (nombre y apellidos) de los socios de la
biblioteca.

CREATE TABLE socio (
   id_socio CHAR (5)PRIMARY KEY,
   nombre VARCHAR(30) NOT NULL,
   apellidos VARCHAR(60) NOT NULL,
   fecha_inscripcion DATE ,
   CONSTRAINT NN_nombre CHECK (nombre IS NOT NULL),
   CONSTRAINT NN_apellidos CHECK (apellidos IS NOT NULL)
);


CREATE TABLE prestamo (
   id_prestamo CHAR(7) PRIMARY KEY,
   id_socio CHAR(5),
   id_ejemplar CHAR(6),
   fecha_inicio DATE ,
   fecha_fin DATE,
   CONSTRAINT FK_prestamo_id_socio FOREIGN KEY (id_socio) REFERENCES socio(id_socio),
   CONSTRAINT FK_prestamo_id_ejemplar FOREIGN KEY (id_ejemplar) REFERENCES ejemplar(id_edicion),
   CONSTRAINT NN_id_socio CHECK (id_socio IS NOT NULL),
   CONSTRAINT NN_id_ejemplar CHECK (id_ejemplar IS NOT NULL)
);











