Trabajo final AD:
--La tabla obra contiene la información de las obras literarias.

CREATE TABLE obra (
id CHAR(5),
titulo VARCHAR(100),
anyo INTEGER,
CONSTRAINT PK_obra PRIMARY KEY (id),
CONSTRAINT NN_titulo CHECK (titulo IS NOT NULL)
);


--La tabla autor contiene la información de los autores de las obras.

CREATE TABLE autor (
id CHAR(4),
nombre VARCHAR(30),
apellidos VARCHAR(60),
nacimiento DATE,
CONSTRAINT PK_autor PRIMARY KEY (id),
CONSTRAINT NN_nombre CHECK (nombre IS NOT NULL),
CONSTRAINT NN_apellidos CHECK (apellidos IS NOT NULL)
);


--La tabla autor_obra contiene la relación de autores y obras.

CREATE TABLE autor_obra (
id_autor CHAR(4),
id_obra CHAR(5),
CONSTRAINT PK_autor_obra PRIMARY KEY (id_autor, id_obra),
CONSTRAINT FK_autor_obra_id_autor FOREIGN KEY (id_autor) REFERENCES
autor(id),
CONSTRAINT FK_autor_obra_id_obra FOREIGN KEY (id_obra)
REFERENCES obra(id)
);



--La tabla edicion contiene la información de las ediciones publicadas de las obras.

CREATE TABLE edicion (
id CHAR(6),
id_obra CHAR(5),
isbn VARCHAR(20),
anyo INTEGER,
CONSTRAINT PK_edicion PRIMARY KEY (id),
CONSTRAINT NN_id_obra CHECK (id_obra IS NOT NULL),
CONSTRAINT NN_isbn CHECK (isbn IS NOT NULL),
CONSTRAINT FK_edicion FOREIGN KEY (id_obra) REFERENCES
obra(id)
);




--La tabla ejemplar contiene la información de los ejemplares adquiridos por labiblioteca.

CREATE TABLE ejemplar (
id_edicion CHAR(6),
numero INTEGER,
alta DATE,
baja DATE,
CONSTRAINT PK_ejemplar PRIMARY KEY (id_edicion, numero),
CONSTRAINT FK_ejemplar FOREIGN KEY (id_edicion) REFERENCES
edicion(id),
CONSTRAINT NN_alta CHECK (alta IS NOT NULL)
);

Select * from obra;
Select * from autor;
Select * from autor_obra;
Select * from edicion;
Select * from ejemplar;
Select * from historial_obras;
///////////////////////////////////////////////////////////////////////////////////

--Tabla para guardar los borrados (se utiliza en el punto 9.1)

CREATE TABLE historial_obras (
   id CHAR(5),
   titulo VARCHAR(100),
   anyo INTEGER,
   fecha_borrado TIMESTAMP,
   CONSTRAINT PK_historial_obras PRIMARY KEY (id, fecha_borrado)
);

CREATE TABLE historial_autor (
   id CHAR(4),
   nombre VARCHAR(30),
   apellidos VARCHAR(60),
   nacimiento DATE,
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50),
   CONSTRAINT FK_historial_autor_id FOREIGN KEY (id) REFERENCES autor(id),
   CONSTRAINT PK_historial_autor PRIMARY KEY (id, fecha_cambio)
);


CREATE TABLE historial_autor_obra (
   id_autor CHAR(4),
   id_obra CHAR(5),
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50), 
   CONSTRAINT FK_historial_autor_obra_id_autor FOREIGN KEY (id_autor) REFERENCES autor(id),
   CONSTRAINT FK_historial_autor_obra_id_obra FOREIGN KEY (id_obra) REFERENCES obra(id)
);

CREATE TABLE historial_edicion (
   id CHAR(6),
   id_obra CHAR(5),
   isbn VARCHAR(20),
   anyo INTEGER,
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50),
   CONSTRAINT FK_historial_edicion_id_edicion FOREIGN KEY (id) REFERENCES edicion(id),
   CONSTRAINT FK_historial_edicion_id_obra FOREIGN KEY (id_obra) REFERENCES obra(id),
   CONSTRAINT PK_historial_edicion PRIMARY KEY (id, fecha_cambio)
);

CREATE TABLE historial_ejemplar (
   id_edicion CHAR(6),
   numero INTEGER,
   alta DATE,
   baja DATE,
   fecha_cambio TIMESTAMP,
   tipo_cambio VARCHAR(50),
   CONSTRAINT FK_historial_ejemplar_id_edicion FOREIGN KEY (id_edicion) REFERENCES edicion(id),
   CONSTRAINT PK_historial_ejemplar PRIMARY KEY (id_edicion, numero, fecha_cambio)
);

//////////////////////////////////////////////////////////////////////////////////////
06. Los identificadores serán alfanuméricos y generados de forma aleatoria. Por
supuesto habrá que tener en cuenta antes de realizar la inserción que la PK no esté
duplicada, caso de estarlo terminaremos de forma controlada el intento de inserción
monitorizando por pantalla el error.


DECLARE

   id4 CHAR(4);
   id5 CHAR(5); 
   id6 CHAR(6);

BEGIN
   -- Generar un identificador alfanumérico de 4 caracteres
   id4 := DBMS_RANDOM.STRING('X', 4);
   -- Generar un identificador alfanumérico de 5 caracteres
   id5 := DBMS_RANDOM.STRING('X', 5);
   -- Generar un identificador alfanumérico de 6 caracteres
   id6 := DBMS_RANDOM.STRING('X', 6);
   -- Intentar insertar una obra
   BEGIN
      INSERT INTO obra (id, titulo) VALUES (id5, 'Cinco semanas en globo');
      INSERT INTO autor (id, nombre, apellidos, nacimiento) VALUES (id4, 'Julio', 'Verne', TO_DATE('1828-02-08', 'YYYY-MM-DD'));
      INSERT INTO autor_obra(id_autor, id_obra) VALUES (id4,id5);
      INSERT INTO edicion(id, id_obra, isbn, anyo) VALUES (id6, id5,'1234567890',2022);
      INSERT INTO ejemplar (id_edicion, numero, alta, baja) VALUES (id6, 1, TO_DATE('2022-03-01', 'YYYY-MM-DD'), NULL);
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         -- Capturar la excepción si la clave primaria está duplicada
         DBMS_OUTPUT.PUT_LINE('Error: Clave primaria duplicada. Inserción abortada.');
   END;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////
08. El alta de obras se implementará mediante una función alta_obra.

CREATE OR REPLACE FUNCTION alta_obra(p_titulo VARCHAR, p_anyo INTEGER DEFAULT NULL)
RETURN VARCHAR IS
   -- Declaraciones
   id_obra VARCHAR(5);
BEGIN
   -- Generar un identificador alfanumérico de 5 caracteres
   id_obra := DBMS_RANDOM.STRING('X', 5);

   -- Insertar la nueva obra
   BEGIN
      INSERT INTO obra (id, titulo, anyo) VALUES (id_obra, p_titulo, p_anyo);
   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, devolver -1
         RETURN '-1';
   END;

   -- Devolver el ID asignado
   RETURN id_obra;
END;
/

DECLARE
   id_obr VARCHAR(5);
BEGIN
   -- Supongamos que se quiere insertar una obra con el título 'Cinco semanas en globo'
   id_obr := alta_obra('Cinco semanas en globo',2022);

   -- Verificar si la operación fue exitosa
   IF id_obr = '-1' THEN
      DBMS_OUTPUT.PUT_LINE('Error al insertar la obra. No se pudo asignar un ID.');
   ELSE
      DBMS_OUTPUT.PUT_LINE('ID asignado: ' || id_obr);
   END IF;
END;
/


/////////////////////////////////////////////////////////////////////////////////////////

09. El borrado de obras se implementará mediante una función borrado_obra.
CREATE OR REPLACE FUNCTION borrado_obra(p_id VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_existencia INTEGER;
BEGIN
   v_existencia := 0;
   -- Verificar si existe la obra con el id proporcionado
   SELECT COUNT(*) INTO v_existencia
   FROM obra
   WHERE id = p_id;

   -- Realizar el borrado si la obra existe
   IF v_existencia > 0 THEN
      DELETE FROM obra WHERE id = p_id;
      RETURN 1; -- Borrado efectuado
   ELSE
      RETURN 0; -- No existe el id
   END IF;
 
   EXCEPTION
	WHEN OTHERS THEN
	   RETURN -1;
END;
/

SET SERVEROUTPUT ON; -- Esto habilita la salida de DBMS_OUTPUT

DECLARE
   resultado INTEGER;
   id_obr VARCHAR(5);
BEGIN
   -- Supongamos que ya existe una obra con el ID 'ABCDE'
   id_obr := 'XNU0I';

   -- Llamada a la función borrado_obra
   resultado := borrado_obra(id_obr);

   -- Mostrar el resultado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('La obra se ha borrado exitosamente.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe una obra con el ID proporcionado.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Ha ocurrido un error durante el borrado de la obra.');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Resultado desconocido.');
   END CASE;
END;
/


//////////////////////////////////////////////////////////////////////////////////////////

09.1 Auditoría del borrado de obras: Cada vez que se ejecute el borrado de una obra y
para no perder datos, lo que querremos es que la obra borrada y todos los datos
asociados a ella queden guardados en una/s tabla/s de histórico ocultas al usuario
estándar, de modo que en cualquier momento se pueda auditar el borrado de obras
recuperando todos sus datos y la fecha/hora en que fue borrada la obra.
CREATE OR REPLACE TRIGGER auditar_borrado_obra
AFTER DELETE ON obra
FOR EACH ROW
DECLARE
   -- Declaraciones
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar los datos de la obra borrada en la tabla de historial_obras
   INSERT INTO historial_obras (id, titulo, anyo, fecha_borrado)
   VALUES (:OLD.id, :OLD.titulo, :OLD.anyo, v_fecha_hora);
   
   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de obra ID ' || :OLD.id || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/


CREATE OR REPLACE TRIGGER auditar_borrado_autor_obra
AFTER DELETE ON autor_obra
FOR EACH ROW
DECLARE
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar la relación de autor y obra borrada en la tabla de historial_autor_obra
   INSERT INTO historial_autor_obra (id_autor, id_obra, fecha_cambio, tipo_cambio)
   VALUES (:OLD.id_autor, :OLD.id_obra, v_fecha_hora, 'DELETE en autor_obra');

   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de autor_obra ID_Autor ' || :OLD.id_autor || ' ID_Obra ' || :OLD.id_obra || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/

CREATE OR REPLACE TRIGGER auditar_borrado_edicion
AFTER DELETE ON edicion
FOR EACH ROW
DECLARE
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar los datos de la edición borrada en la tabla de historial_edicion
   INSERT INTO historial_edicion (id, id_obra, isbn, anyo, fecha_cambio, tipo_cambio)
   VALUES (:OLD.id, :OLD.id_obra, :OLD.isbn, :OLD.anyo, v_fecha_hora, 'DELETE en edicion');

   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de edicion ID ' || :OLD.id || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/

CREATE OR REPLACE TRIGGER auditar_borrado_ejemplar
AFTER DELETE ON ejemplar
FOR EACH ROW
DECLARE
   v_fecha_hora TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
   -- Insertar los datos del ejemplar borrado en la tabla de historial_ejemplar
   INSERT INTO historial_ejemplar (id_edicion, numero, alta, baja, fecha_cambio, tipo_cambio)
   VALUES (:OLD.id_edicion, :OLD.numero, :OLD.alta, :OLD.baja, v_fecha_hora, 'DELETE en ejemplar');

   -- Puedes agregar más información a la salida de mensajes si es necesario
   DBMS_OUTPUT.PUT_LINE('Borrado de ejemplar ID_Edicion ' || :OLD.id_edicion || ' Numero ' || :OLD.numero || ' auditable. Fecha/Hora: ' || TO_CHAR(v_fecha_hora, 'YYYY-MM-DD HH24:MI:SS'));
END;
/


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10. El alta de autores se implementará mediante una función alta_autor.


CREATE OR REPLACE FUNCTION alta_autor(p_nombre VARCHAR, p_apellidos VARCHAR, p_nacimiento DATE DEFAULT NULL)
RETURN VARCHAR IS
   -- Declaraciones
   id_autor CHAR(4);
BEGIN
   -- Generar un identificador alfanumérico de 4 caracteres
   id_autor := DBMS_RANDOM.STRING('X', 4);
	
   -- Insertar la nueva obra
   BEGIN
      INSERT INTO autor (id, nombre, apellidos, nacimiento) VALUES (id_autor, p_nombre, p_apellidos, p_nacimiento);
   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, devolver -1
         RETURN '-1';
   END;

   -- Devolver el ID asignado
   RETURN id_autor;
END;
/

DECLARE
   id_autor VARCHAR(4);
BEGIN
   -- Supongamos que se quiere insertar un autor con el nombre 'Julio' y apellidos 'Cesar'
   -- y se proporciona el año de nacimiento como 2022
   id_autor := alta_autor('Julio', 'Cesar', DATE '2022-01-01');

   -- Verificar si la operación fue exitosa
   IF id_autor = '-1' THEN
      DBMS_OUTPUT.PUT_LINE('Error al insertar el autor. No se pudo asignar un ID.');
   ELSE
      DBMS_OUTPUT.PUT_LINE('ID asignado: ' || id_autor);
   END IF;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

11. El borrado de autores se implementará mediante una función borrado_autor.

CREATE OR REPLACE FUNCTION borrado_autor(p_id VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_existencia INTEGER ;

BEGIN
    v_existencia := 0;
   -- Verificar si existe la autor con el id proporcionado
   SELECT COUNT(*) INTO v_existencia
   FROM autor
   WHERE id = p_id;

   -- Intentar borrar el autor
 	IF v_existencia > 0 THEN
      DELETE FROM autor WHERE id = p_id;
      RETURN 1; -- Borrado efectuado
   ELSE
      RETURN 0; -- No existe el id
   END IF;
 
   EXCEPTION
	WHEN OTHERS THEN
	   RETURN -1;
      
END;
/
DECLARE
   resultado INTEGER;
   id_autor VARCHAR(4); 

BEGIN
    id_autor := 'TY5Q';
    resultado := borrado_autor(id_autor);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Autor borrado exitosamente.');
      WHEN 0 THEN
         DBMS_OUTPUT.PUT_LINE('No existe un autor con ese ID.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Error al intentar borrar el autor.');
   END CASE;
END;
/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////


12. La vinculación de un autor a una obra se implementará mediante una función
vincular.



CREATE OR REPLACE FUNCTION vincular_autor_obra(p_id_autor VARCHAR, p_id_obra VARCHAR) RETURN INTEGER IS
   -- Declaraciones
   v_resultado INTEGER := 1;  -- Por defecto, asumimos que la operación se realiza sin errores.

BEGIN
   -- Intentar vincular el autor a la obra
   BEGIN
      INSERT INTO autor_obra (id_autor, id_obra) VALUES (p_id_autor, p_id_obra);
      
      COMMIT;  -- Confirmar la transacción si la inserción fue exitosa

   EXCEPTION
      WHEN OTHERS THEN
         -- Si ocurre un error, asignar -1 al resultado y realizar un rollback
         v_resultado := -1;
         ROLLBACK;
   END;

   -- Devolver el resultado
   RETURN v_resultado;
END;
/
DECLARE
   resultado INTEGER;
   id_autor CHAR(4) ; 
   id_obra CHAR(5) ;  

BEGIN
    id_autor :='';
	id_obra :='';
   resultado := vincular(id_autor, id_obra);

   -- Verificar el resultado y mostrar un mensaje adecuado
   CASE resultado
      WHEN 1 THEN
         DBMS_OUTPUT.PUT_LINE('Vinculación exitosa.');
      WHEN -1 THEN
         DBMS_OUTPUT.PUT_LINE('Error al intentar vincular el autor a la obra.');
   END CASE;
END;
/



















